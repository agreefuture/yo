- [ ] reference counting
- [ ] `self.foo += x;` assignments (currently kinda works as a side effect of implicit seld access, ie `foo += 1` if self has a foo attribute)
- [ ] chained property access
- [ ] chained method calls
- [ ] tests
- [x] bitwise operators (NOT, AND, OR, XOR)
- [x] bitshift operators
- [ ] implement bools
- [ ] add support for floating point numbers (custom instructions `addf`, `subf`, `mulf` `divf`, what about `mod`, `not`, etc?)
- [x] array literals (TODO improve)
- [ ] nested binops (`((1 << 4) << 7)`) (TODO check, this might already work)
- [x] binary number literals
- [x] `ret obj[0] & 1048575;`
- [ ] underscores in number literals
- [ ] implicitly import stdlib modules (ie import "std/string" if the code contains a string literal, same for numbers, arrays)
- [ ] test that the examples in the documentation actually work
- [x] auto-synthesize `dealloc` functions (only if not otherwise defined)
- [ ] throw an error when the stack grows into allocated heap space / vice versa
- [x] implement some sort of `fatalError` function to abort w/ an error message
- [x] `Array.get`: negative index to access elements from back
- [ ] ternary expressions (only for assignment at first)
- [ ] elvis operator (`a ?? b`)
- [ ] `else if`
- [x] add type checks when assigning the return value of a function?
- [ ] macros
- [ ] make `nil` a macro for `0 as id`
- [x] `break` out of `for`/`while` loops
- [ ] ensure that all custom `dealloc` methods return `void`
- [ ] ensure that `void` returning functions don't return anything other than `void`
- [ ] disallow `void` variable declarations (and function parameters)? they're currently treated as ints (as in also getting allocated stack space)
- [ ] support casts in chained access `(5 as Foo).bar`
- [x] `Self` to refer to whatever the current type is
- [ ] short circuit evaluation
- [ ] compile time check to make sure that format functions are passed the correct number of arguments (maybe introduce some sort of annotation or macro that can be applied to functions to tell the compiler to run that check, like objc's `NS_FORMAT_FUNCTION`)
- [ ] remove unused functions from the generated instructions?
- [ ] custom string literal prefix/suffix functions (like what ES6 and c++ have) (maybe via a macro thing)
- [ ] pass static function reference as argument (ie `array.forEach(io::printi)`)
- [ ] allow `val` etc to be used as identifiers, if fit
- [ ] make sure typenames used in function signatures actually exist
- [ ] `#expr` to get an array's length
- [ ] reset parsed annotations when they'd become invalid (not sure if this is actually a problem)
- [ ] allow disabling arc for an entire type/impl block
- [ ] allow disabling getters/setters for individual attributes
- [ ] don't evaluate function arguments right to left
- [ ] simple heap array literal. ie `val x = {1, 3, 4};` would call `runtime::alloc(3)` and fill that w/ 1, 3 and 4
- [ ] always zero out the newly allocated backing range on `runtime::alloc`
- [ ] throw descriptive error when accessing a nonexistent attribute
- [x] allow `ret;` instead of `ret 0;` in void functions
- [ ] if a function doesn't specify a return type, use `void` as default
- [ ] type inference for static variables
- [ ] make `namespace`s a thing
      (collection of static functions, basically the same that can already be achieved by using an `impl` for a nonexistent type)
      The difference would be that a) you can't declare a `type` or `struct` w/ that name and b) all functions are implicitly static
- [ ] `defer`
- [ ] don't allow creating attributes w/ nonexistent types (seems to work fine so far which it shouldnt)

// object

use "std/string";
use "std/number";

// every custom type you declare implicitly conforms to the `Object` protocol

#[base_protocol]
protocol Object {
    fn hashValue(self: Self): int {
        ret self as int;
    }

    fn description(self: Self): String {
        ret Object::_description(self);
    }

    fn isEqualTo(self: Self, other: Self): bool {
        if self == other {
            ret true;
        }
        ret false;
    }
}


impl Object {
    // Call some object's `description` method
    static fn description(obj: id): String {
        val metatype = runtime::typeof(obj);
        val description_fn_ptr = metatype.vtable.description as fn<(id): String>;
        ret description_fn_ptr(obj);
    }

    // The default implementation of -[id description]
    static fn _description(obj: id): String {
        val metatype = runtime::typeof(obj);
        ret String::format("<%s %nh>", metatype.name, @(obj as int));
    }

    static fn _isEqualTo(obj1: id, obj2: id): bool {
        val metatype = runtime::typeof(obj1);
        val isEqualTo_fn = metatype.vtable.isEqualTo as fn<(id, id): bool>;
        ret isEqualTo_fn(obj1, obj2);
    }
}

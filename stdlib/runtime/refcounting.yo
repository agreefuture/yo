// WIP

#[extern] fn raise(i32);


#[always_inline]
fn retain<T>(obj: T) -> T {
    retain_imp(reinterpret_cast<*LKMetadataAccessor>(obj));
    return obj;
}

#[always_inline]
fn release<T>(obj: T) {
    release_imp(reinterpret_cast<*LKMetadataAccessor>(obj));
    return;
}

#[always_inline]
fn markForRelease<T>(obj: T) {
    markForRelease_imp(reinterpret_cast<*LKMetadataAccessor>(obj));
    return;
}




#[no_init]
struct LKMetadataAccessor {
    retainCount: u64,
    deallocPtr: #[convention=C] (*i8) -> void
}


fn get_retainCount_imp(obj: *LKMetadataAccessor) -> u64 {
    //let rc = obj.retainCount;
    //rc &= static_cast<u64>(~(1 << 60));
    //return rc;
    return obj.retainCount & static_cast<u64>(~(1 << 60));
}

//fn unsetIsMarkedForReleaseBit_imp(obj: *LKMetadataAccessor) {
//    obj.retainCount &= static_cast<u64>(~(1 << 60));
//    return;
//}

fn retain_imp(obj: *LKMetadataAccessor) -> void {
    if isMarkedForRelease_imp(obj) {
        obj.retainCount &= static_cast<u64>(~(1 << 60));
        //unsetIsMarkedForReleaseBit_imp(obj);
        return;
    }
    obj.retainCount += 1;
    printf(b"retain_imp: RC: %lu\n", get_retainCount_imp(obj));
    return;
}


fn release_imp(obj: *LKMetadataAccessor) -> void {
    if isMarkedForRelease_imp(obj) {
        obj.retainCount &= static_cast<u64>(~(1 << 60));
    }

    if obj.retainCount == 1 {
        obj.deallocPtr(reinterpret_cast<*i8>(obj));
        return;
    }

    obj.retainCount -= 1;
    printf(b"release_imp: RC: %lu\n", get_retainCount_imp(obj));
    return;
}


fn isMarkedForRelease_imp(obj: *LKMetadataAccessor) -> bool {
    return obj.retainCount & static_cast<u64>(1 << 60) != 0;
}


fn markForRelease_imp(obj: *LKMetadataAccessor) {
    obj.retainCount |= static_cast<u64>(1 << 60);
    return;
}

use "std/string";
use "std/string_builder";
use "math";

static _maxSizeIndex: int = 5;
static _primes: int = {13, 23, 41, 71, 127, 421};
static HashMapEmptySlotIndicator: any = 0;

#[static_cleanup]
fn _freePrimes(): void {
    runtime::free(_primes);
}


#[disable_metadata]
struct HashMapKeyValuePair {
    key: String,
    value: id
}


struct HashMap {
    _usedSize: i64,
    _allocatedSize: i64,
    _sizeIndex: i64,
    _backing: ref i64
}


impl HashMap {
    static fn new(): HashMap {
        return HashMap::_withSize(_primes[0], 0);
    }

    static fn _withSize(size: int, sizeIndex: int): HashMap {
        return HashMap::init(0, size, sizeIndex, runtime::alloc(2 * 8 * size) as ref i64);
    }


    fn insert(self: HashMap, key: String, value: id): void {
        if self._usedSize >= (self._allocatedSize - 5) {
            self._resize(true);
        }

        if self.get(key) {
            // key already present -> replace w/ new value
            self.remove(key);
            self.insert(key, value);
            return;
        }

        let bucketIndex = self.findBucketForKey(key);
        let pair = self._pairInBucketWithIndex(bucketIndex);

        pair.key = runtime::retain(key);
        pair.value = runtime::retain(value);

        self._usedSize += 1;
    }


    fn get(self: HashMap, key: String): id {
        let pair = self._pairInBucketWithIndex(self.findBucketForKey(key));
        return pair.value;
    }


    // removes a key/value pair from the hash map
    fn remove(self: HashMap, key: String): void {
        let bucketIndex = self.findBucketForKey(key);
        let pair = self._pairInBucketWithIndex(bucketIndex);

        runtime::release(pair.key);
        runtime::release(pair.value);

        pair.key = HashMapEmptySlotIndicator;
        pair.value = HashMapEmptySlotIndicator;
    }


    fn _resize(self: HashMap, makeLarger: bool): void {
        let newSize: int;
        let newSizeIndex: int;
        if makeLarger {
            if self._sizeIndex != -1 && self._sizeIndex < _maxSizeIndex {
                newSizeIndex = self._sizeIndex + 1;
                newSize = _primes[newSizeIndex];
            } else {
                // largest size index maps to 421. if we exceed that, it's likely that many objects are being added
                // so it makes sense to increase by a large number
                newSizeIndex = -1;
                newSize = self._allocatedSize + 100;
            }
        } else {
            // TODO implement downsizing
            runtime::fatalError("not yet implemented");
        }

        // What's going on here?
        // We create a new HashMap with the new size (either smaller or larger than `self`)
        // We then insert all key/value pairs from `self` into the new hash map
        // and simply replace our attributes w/ the new hash map's attributes
        // However, since the new hash map (`temp`) gets deallocated when it leaves scope, we have
        // to make sure that its deallocation process won't mess up our backing and our key/value pairs.
        // That's why we
        // a) set temp's `_usedSize` and`_allocatedSize` to 0.
        //    setting _allocatedSize to 0 is important because -[HashMap dealloc] iterates over its
        //    backing to release all objects, but since we set the backing to 0, it would just
        //    release random objects at the beginning of the heap. Also setting _allocatedSize to 0
        //    solves that issue, since -[HashMap enumerateKeyValuePairs] uses _allocatedSize to iterate
        //    over the key/value pairs
        // b) set temp's `_backing` to 0. runtime::free simply returns requests to free 0, so that
        //    ensures that we don't accidentally free some random heap space
        // We also have to re-adjust the key/value pair's retain counts (-1), because inserting them
        // into the new HashMap increases them by one, which is not balanced out.

        let temp = HashMap::_withSize(newSize, newSizeIndex);

        self.enumerateKeyValuePairs(|pair| -> {
            temp.insert(pair.key, pair.value);
            runtime::release(pair.key);
            runtime::release(pair.value);
        });

        runtime::free(self._backing as i64);
        self._sizeIndex = temp._sizeIndex;
        self._allocatedSize = temp._allocatedSize;
        self._backing = temp._backing;

        // make sure temp doesn't free our new backing when it goes out of scope
        // also, since HashMap's dealloc function iterates over the backing, we have to set
        // _usedSize and _allocatedSize to 0, to prevent these iterations
        temp._usedSize = 0;
        temp._allocatedSize = 0;
        temp._backing = 0 as any;
    }

    fn findBucketForKey(self: HashMap, key: String): int {
        let hashValue = abs(key.hashValue());

        // index of the bucket in which the key would be stored under perfect coditions (no collisions)
        let bucketIndex = hashValue % self._allocatedSize;

        for let i: int; i < self._allocatedSize; i += 1; {
            let fetchedKey = self._backing[2 * bucketIndex] as String;
            if fetchedKey == 0 || fetchedKey == HashMapEmptySlotIndicator {
                return bucketIndex;
            } else if fetchedKey.isEqualToString(key) {
                return bucketIndex;
            }

            bucketIndex += 1;

            if bucketIndex == self._allocatedSize {
                bucketIndex = 0;
            }
        }

        runtime::fatalError("unable to find bucket");
    }


    fn description(self: HashMap): String {
        let desc = StringBuilder::new();
        desc.append("HashMap {\n");

        self.enumerateKeyValuePairs(|pair| -> unsafe {
            desc.append_format("    %s = %s\n", pair.key.debugDescription(), pair.value.debugDescription());
        });

        desc.append("}");
        return desc.stringValue();
    }


    fn _debugDescription(self: HashMap): String {
        let desc = StringBuilder::new();
        desc.append("HashMap {\n");
        for let i: int; i < self._allocatedSize; i += 1; {
            let key = self._backing[2 * i] as String;
            let value = self._backing[(2 * i) + 1] as id;

            let key_description: String;
            let value_description: String;

            if key == 0 || key == HashMapEmptySlotIndicator {
                key_description = "0";
            } else {
                key_description = key.description();
            }

            if value == 0 || value == HashMapEmptySlotIndicator{
                value_description = "0";
            } else {
                unsafe { value_description = value.description(); }
            }

            desc.append_format("    [%n] (%s, %s)\n", @i, key_description, value_description);
        }
        desc.append("}");

        return desc.stringValue();
    }


    fn _pairInBucketWithIndex(self: HashMap, bucketIndex: i64): HashMapKeyValuePair {
        let offset = 2 * bucketIndex;
        return ((self._backing as i64) + (offset * 8)) as HashMapKeyValuePair;
    }


    fn enumerateKeyValuePairs(self: HashMap, block: fn<(HashMapKeyValuePair): void>): void {
        // TODO use the _pairInBucketWithIndex method from above?
        for let i: int; i < self._allocatedSize; i += 1; {
            let offset = 2 * i;
            if self._backing[offset] != 0 && self._backing[offset] != HashMapEmptySlotIndicator {
                let pair = ((self._backing as i64) + (offset * 8)) as HashMapKeyValuePair;
                block(pair);
            }
        }
    }


    fn dealloc(self: HashMap): void {
        self.enumerateKeyValuePairs(|pair| -> {
            runtime::release(pair.key);
            runtime::release(pair.value);
        });
        runtime::free(self._backing as i64);
    }
}

// runtime.yo

use "std/object";
use "std/string";

fn NotYetImplemented(): void {
    runtime::fatalError("not yet implemented");
}

static _is_deallocating_bit: int = 30;
static _is_marked_for_release_bit: int = 29;

struct Type (
    id: int,
    name: String,
    vtable: vtable
);

struct vtable (
    dealloc: int,
    description: int,
    isEqualTo: int,
    hashValue: int
);


impl runtime {

    #[disable_arc]
    static fn typeof(obj: any): Type {
        // the upper 32 bit of an object's first field are a pointer to a pointer to the actual metatype
        // see the source code for more information TODO link to source code
        val metatype_ptr = obj[0] >> 32;
        ret metatype_ptr[0];
    }


    #[disable_arc]
    static fn isObject(obj: any): bool {
        if obj == 0 {
            ret false;
        }

        if obj % 2 == 0 {
            if obj[0] == 0 {
                ret false;
            }
            ret true;
        }

        ret false;
    }



    //
    // Reference Counting
    //

    // Increment an object's retain count by 1
    #[disable_arc]
    static fn retain(obj: any): any {
        if !runtime::isObject(obj) {
            ret obj;
        }

        if runtime::isMarkedForRelease(obj) {
            runtime::unmarkForRelease(obj);
            ret obj;
        }

        obj[0] = obj[0] + 1;
    }


    // Decrement an object's retain count by 1
    // If the object's new retain count is 0,
    // we call the object's dealloc method and free it from the heap
    #[disable_arc]
    static fn release(obj: any): any {
        if !runtime::isObject(obj) {
            ret obj;
        }

        if runtime::isMarkedForRelease(obj) {
            // we reach here when releasing the unused return vslue from a function call returning a complex object
            runtime::unmarkForRelease(obj);
        }

        if runtime::getRetainCount(obj) == 1 {
            // the object is already in the process of being deallocated, so we'll just ignore this release call
            if runtime::is_deallocating(obj) {
                ret obj;
            }
            runtime::set_is_deallocating(obj);

            val dealloc_fn: fn<(any): void> = runtime::_getDeallocAddress(obj) as any;
            //runtime::_printi(dealloc_fn as int);
            dealloc_fn(obj);
            runtime::free(obj);
        } else {
            obj[0] = obj[0] - 1;
        }
        ret obj;
    }


    #[disable_arc]
    static fn markForRelease(obj: any): any {
        if !runtime::isObject(obj) {
            ret obj;
        }

        // make sure the same object isn't marked for release twice
        if runtime::isMarkedForRelease(obj) {
            runtime::fatalError("Fatal Error: object is already marked for release");
        }

        obj[0] = obj[0] | (1 << _is_marked_for_release_bit);
        ret obj;
    }

    // newValue should be 0 or 1, everything else is UB
    #[disable_arc]
    static fn unmarkForRelease(obj: any): any {
        if !runtime::isObject(obj) {
            ret obj;
        }

        obj[0] = obj[0] & ~(1 << _is_marked_for_release_bit);
        ret obj;
    }

    #[disable_arc]
    static fn isMarkedForRelease(obj: any): bool {
        if !runtime::isObject(obj) {
            ret false;
        }

        val bit: int = obj[0] & (1 << _is_marked_for_release_bit);
        if bit == 0 {
            ret false;
        }
        ret true;
    }

    #[disable_arc]
    static fn is_deallocating(obj: any): bool {
        if !runtime::isObject(obj) {
            ret false;
        }
        val bit: int = obj[0] & (1 << _is_deallocating_bit);
        if bit == 0 {
            ret false;
        }
        ret true;
    }

    #[disable_arc]
    static fn set_is_deallocating(obj: any): void {
        if !runtime::isObject(obj) {
            ret obj;
        }

        obj[0] = obj[0] & ~(1 << _is_deallocating_bit);
        ret obj;
    }


    #[disable_arc]
    static fn _getDeallocAddress(obj: any): int {
        val metatype = runtime::typeof(obj);
        ret metatype.vtable.dealloc as int;
    }

    #[disable_arc]
    static fn getRetainCount(obj: any): int {
        ret obj[0] & 0x3fffffff;
    }
}


impl runtime {
    // Runtime helper to create a primitive array from an array constant containing only numbers
    // (ie `{1, 2, 3, 4}`)
    // Because primitive array literals consisting only of numbers are stored the same way
    // as complex array literals consisting only of numbers, we have to drop the first element (the size)
    // More information in `BytecodeCompiler.handle(arrayLiteral:)`
    static fn _primitiveArrayFromConstant(input: int): int {
        val size = input[0];
        val array = runtime::alloc(size);

        runtime::copy_array(input, 1, array, 0, size);
        runtime::free(input);

        ret array;
    }

    // Basically java's `Syatem.arraycopy`
    static fn copy_array(source: int, sourceIndex: int, destination: int, destinationIndex: int, length: int): void {
        for i in 0..<length {
            destination[destinationIndex + i] = source[sourceIndex + i];
        }
    }
}

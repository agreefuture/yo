// runtime.yo

use "std/object";
use "std/string";

impl runtime {

    // Note: type ids are not guaranteed to be the same across different compilations of the same program
    #[disable_arc]
    static fn getTypeId(obj: any): int {
        ret obj[0] & 0xfffff;
    }


    #[disable_arc]
    static fn isObject(obj: any): bool {
        if obj == 0 {
            ret false;
        }

        if obj % 2 == 0 {
            if obj[0] == 0 {
                ret false;
            }
            ret true;
        }

        ret false;
    }



    //
    // Reference Counting
    //

    // Increment an object's retain count by 1
    #[disable_arc]
    static fn retain(obj: any): any {
        if !runtime::isObject(obj) {
            ret obj;
        }

        if runtime::isMarkedForRelease(obj) {
            runtime::unmarkForRelease(obj);
            ret obj;
        }

        ret runtime::_setRetainCount(obj, runtime::getRetainCount(obj) + 1);
    }


    // Decrement an object's retain count by 1
    // If the object's new retain count is 0,
    // we call the object's dealloc method and free it from the heap
    #[disable_arc]
    static fn release(obj: any): any {
        if !runtime::isObject(obj) {
            ret obj;
        }

        if runtime::isMarkedForRelease(obj) {
            // we reach here when releasing the unused return vslue from a function call returning a complex object
            runtime::unmarkForRelease(obj);
        }

        if runtime::getRetainCount(obj) {
            val dealloc_fn: fn<(any): void> = runtime::_getDeallocAddress(obj) as any;
            dealloc_fn(obj);
            runtime::free(obj);
        } else {
            runtime::_setRetainCount(obj, runtime::getRetainCount(obj) - 1);
        }
        ret obj;
    }

    // 0000|00000000000000000000|00000000000000000000|00000000000000000000
    // 0000|dddddddddddddddddddd|rrrrrrrrrrrrrrrrrrrr|tttttttttttttttttttt
    // ----|--------------------|--------------------|--------------------
    // 6666|55555555554444444444|33333333332222222222|11111111110000000000
    // 3210|98765432109876543210|98765432109876543210|98765432109876543210


    #[disable_arc]
    static fn markForRelease(obj: any): any {
        if !runtime::isObject(obj) {
            ret obj;
        }

        // make sure the same object isn't marked for release twice
        if runtime::isMarkedForRelease(obj) {
            runtime::fatalError("Fatal Error: object is already marked for release");
        }

        obj[0] = obj[0] | (1 << 39);
        ret obj;
    }

    // newValue should be 0 or 1, everything else is UB
    #[disable_arc]
    static fn unmarkForRelease(obj: any): any {
        if !runtime::isObject(obj) {
            ret obj;
        }

        obj[0] = obj[0] & ~(1 << 39);
        ret obj;
    }

    #[disable_arc]
    static fn isMarkedForRelease(obj: any): bool {
        if !runtime::isObject(obj) {
            ret false;
        }

        val bit: int = obj[0] & (1 << 39);
        if bit == 0 {
            ret false;
        }
        ret true;
    }


    #[disable_arc]
    static fn _getDeallocAddress(obj: any): int {
        ret obj[0] >> 40;
    }


    #[disable_arc]
    static fn _setRetainCount(obj: any, newValue: int): any {
        val typeId = runtime::getTypeId(obj);
        val deallocAddress = runtime::_getDeallocAddress(obj);

        obj[0] = (deallocAddress << 40);
        obj[0] = obj[0] | (newValue << 20);
        obj[0] = obj[0] | typeId;

        //obj[0] = (deallocAddress << 40) | (newValue << 20) | typeId;

        ret obj;
    }


    #[disable_arc]
    static fn getRetainCount(obj: any): int {
        val retainCount: int = obj[0] & 0xfffff00000;
        ret retainCount >> 20;
    }
}

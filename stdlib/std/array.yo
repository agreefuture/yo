type Array(count: int, _allocatedLength: int, _backing: int[]);

// TODO write tests for all of this!


impl Array {
    // Create a new Array
    static fn new(): Array {
        ret Array::init(0, 5, runtime::alloc(5));
    }


    // Add an object to the array
    fn add(self: Array, object: int): int {
        if self.count == self._allocatedLength {
            // array is full, we need to switch to a bigger backing

            // TODO come up w/ some clever algorithm determining the new backing length?
            val newLength: int = self._allocatedLength + 10;
            val newBacking: int[] = runtime::alloc(newLength);

            val idx: int = 0;
            while idx < self.count {
                newBacking[idx] = self._backing[idx];
                idx += 1;
            }

            runtime::free(self._backing);
            self._backing = newBacking;
            self._allocatedLength = newLength;
        }

        self._backing[self.count] = object;
        self.count = self.count + 1; // TODO make this `self.count += 1;`
        ret self.count;
    }


    // Get the object at `index`
    fn get(self: Array, index: int): int {
        if index < 0 || index > (self.count - 1) {
            ret -1; // TODO throw an error or exit the program
        }
        ret self._backing[index];
    }


    // Set the object at `index`
    // Returns the previous value
    fn set(self: Array, index: int, object: int): int {
        if index < 0 || index  > (self.count - 1) {
            ret -1; // TODO throw an error or exit the program
        }

        val oldValue: int = self.get(index);
        self._backing[index] = object;
        ret oldValue;
    }


    // Check whether the array contains an object
    fn contains(self: Array, object: int): int {
        // TODO
    }


    // Get the number of objects in the array
    fn length(self: Array): int {
        ret self.count;
    }


    fn dealloc(self: Array): int {
        runtime::free(self._backing);
    }
}

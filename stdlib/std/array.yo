use "std/range";
use "std/string";
use "std/string_builder";

struct Array {
    _count: int,
    _allocatedLength: int,
    // TODO make _backing `*int`?
    _backing: int
}

// TODO write tests for all of this!


impl Array {
    // Create a new Array
    static fn new(): Array {
        return Array::init(0, 10, runtime::alloc(10 * 8));
    }


    // Add an object to the array
    // TODO make `object` id and require it to be a heap allocated instance
    fn append(self: Array, object: id): int {
        if self._count == self._allocatedLength {
            // array is full, we need to switch to a bigger backing

            // TODO come up w/ some clever algorithm determining the new backing length?

            // TODO what if `self` is an array from a literal? that means that _allocatedLength == count for any count.
            // the issue w/ that is that if we just add 10, we might have an odd allocated length
            self._resizeBacking(self._allocatedLength + 10);
        }

        self._backing[self._count] = object;
        runtime::retain(object);

        self._count += 1;
        return self._count;
    }


    // Get the object at `index`
    fn get(self: Array, index: int): id {
        return self._backing[self._normalizeIndexAndCheckBounds(index)] as id;
    }


    // Set the object at `index`
    // Returns the previous value
    fn set(self: Array, index: int, object: id): id {
        index = self._normalizeIndexAndCheckBounds(index);
        let oldValue = self.get(index);
        runtime::release(oldValue);
        self._backing[index] = object;
        runtime::retain(object);
        return oldValue;
    }


    // Check whether the array contains an object
    fn contains(self: Array, object: id): bool {
        if self.indexOf(object) == -1 {
            return false;
        }
        return true;
    }


    // Get the first index of an object in the array
    // Returns -1 if the array does not contain the object
    fn indexOf(self: Array, obj: id): int {
        //for i in 0..<self._count {
        for let i = 0; i < self._count; i += 1; {
            if self.get(i) == obj {
                return i;
            }
            if Object::_isEqualTo(self.get(i), obj) {
                return i;
            }
        }
        return -1;
    }


    // Remove all occurrences of an object from the array
    fn remove(self: Array, object: id): void {
        NotYetImplemented();
        // TODO take a reduced length due to mutations into account!!!
        //for i in 0..<self._count {
        for let i = 0; i < self._count; i += 1; {
            // TODO we probably should also check the object's hash values or call isEqual or something like that
            if self.get(i) == object {
                self.removeAtIndex(i);
            }
        }
    }


    // Remove the object at the specified index
    fn removeAtIndex(self: Array, index: int): void {
        index = self._normalizeIndexAndCheckBounds(index);

        runtime::release(self.get(index));

        self._count = self._count - 1;

        runtime::copy_array(8, self._backing, index + 1, self._backing, index, self._count - index);

        if (self._allocatedLength - self._count) >= 5 {
            self._resizeBacking(self._allocatedLength - 5);
        }
    }


    // Sort the array using a custom sorting function
    // `f` should return true if the elements are in ascending order
    fn sort(self: Array, f: fn<(id, id): bool>): void {
        runtime::sortf(self._backing as *i64, self._count, 8, f);
    }


    fn forEach(self: Array, f: fn<(id): void>): void {
        //for i in 0..<self._count {
        for let i = 0; i < self._count; i += 1; {
            f(self.get(i));
        }
    }


    fn enumerate(self: Array, f: fn<(int, id): void>): void {
        //for i in 0..<self._count {
        for let i = 0; i < self._count; i += 1; {
            f(i, self.get(i));
        }
    }


    fn map(self: Array, f: fn<(id): id>): Array {
        let newArray = Array::new();

        //for i in 0..<self._count {
        for let i = 0; i < self._count; i += 1; {
            newArray.append(f(self.get(i)));
        }

        return newArray;
    }


    fn filter(self: Array, f: fn<(id): bool>): Array {
        let newArray: Array = Array::new();

        //for i in 0..<self._count {
        for let i = 0; i < self._count; i += 1; {
            let element = self.get(i);
            if f(element) {
                newArray.append(element);
            }
        }
        return newArray;
    }


    fn reduce(self: Array, initial: any, f: fn<(any, id): any>): any {
        for let i = 0; i < self._count; i += 1; {
        //for i in 0..<self._count {
            initial = f(initial, self.get(i));
        }

        return initial;
    }


    fn reduceInto(self: Array, obj: any, f: fn<(any, id): void>): any {
        self.forEach(|x| -> {
            f(obj, x);
        });

        return obj;
    }


    // Get the number of objects in the array
    fn count(self: Array): int {
        return self._count;
    }


    fn dealloc(self: Array): void {
        for let i: int; i < self._count; i += 1; {
            runtime::release(self.get(i));
        }
        runtime::free(self._backing);
    }


    fn description(self: Array): String {
        let desc = StringBuilder::new();
        desc.append("Array {\n");

        // TODO append commas to all elements except the last
        self.forEach(|x| -> {
            desc.append_format("    %s\n", Object::description(x));
        });

        desc.append("}");
        return desc.stringValue();
    }


    //
    // MARK: Helpers
    //

    fn _normalizeIndexAndCheckBounds(self: Array, index: int): int {
        if index < 0 {
            index = self._count + index;
        }

        if index > self._count - 1 {
            runtime::fatalError("array index out of bounds");
        }

        return index;
    }

// TODO
//    fn hashValue(self: Array): int {
//        ret 12;
//    }


    // Move to a smaller/larger backing
    // Also updates `_allocatedLength`
    fn _resizeBacking(self: Array, newSize: int): void {
        let newBacking: int = runtime::alloc(newSize * 8);

        runtime::copy_array(8, self._backing, 0, newBacking, 0, self._count);

        runtime::free(self._backing);
        self._backing = newBacking;
        self._allocatedLength = newSize;
    }
}


impl Array: Iterable {
    fn iterator(self: Array): ArrayIterator {
        return ArrayIterator::newWithArray(self);
    }
}




struct ArrayIterator {
    index: int,
    array: Array
}

impl ArrayIterator: Iterator {
    static fn newWithArray(array: Array): ArrayIterator {
        return ArrayIterator::init(0, array);
    }


    fn hasNext(self: ArrayIterator): bool {
        if self.index < self.array.count() {
            return true;
        }
        return false;
    }

    fn next(self: ArrayIterator): any {
        let element = self.array.get(self.index);
        self.index += 1;
        return element;
    }
}

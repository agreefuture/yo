use ":std/memory";

struct ArrayIterator<T> {
    array: &Array<T>,
    idx: i64
}

impl ArrayIterator {
    fn init(self: &Self, array: &Array<T>) {
        self.init(array, 0);
    }

    fn hasNext(self: &Self) -> bool {
        return self.idx < self.array.size;
    }

    fn next(self: &Self) -> &T {
        let &elem = self.array[self.idx];
        self.idx += 1;
        return elem;
    }
}



struct Array<T> {
    data: *T,
    size: i64,
    allocSize: i64
}

impl Array {
    fn init(self: &Self) {
        self.data = alloc<T>(10);
        self.allocSize = 10;
    }

    fn init(self: &Self, other: &Array<T>) {
        self.allocSize = other.allocSize;
        self.data = alloc<T>(cast<size_t>(self.allocSize));
        while self.size < other.size {
            self._constructInPlace(self.size, other[self.size]);
            self.size += 1;
        }
    }

    fn operator [] (self: &Self, index: i64) -> &T {
        return self.data[index];
    }

    fn iterator(self: &Self) -> ArrayIterator<T> {
        return ArrayIterator<T>(self);
    }


    fn append(self: &Self, element: T) {
        if self.size >= self.allocSize - 2 {
            self._resize(25); // TODO dynamically calculate growth factor!
        }
        self._constructInPlace(self.size, element);
        self.size += 1;
    }

    
    fn remove(self: &Self, index: i64) {
        fatalError("TODO: implement");
    }


    // Inserts a new element, invoking the copy constructor if necessary
    fn _constructInPlace(self: &Self, index: i64, element: &T) {
        if __is_constructible<T>() {
            self.data[index].init(element);
        } else {
            self.data[index] = element;
        }
    }

    
    fn _resize(self: &Self, diff: i64) {
        let ptr = alloc<T>(cast<size_t>(self.allocSize + diff));
        memcpy(bitcast<*i8>(ptr), bitcast<*i8>(self.data), cast<size_t>(self.size) * sizeof<T>());
        dealloc(self.data);
        self.data = ptr;
    }




    fn filtered<F>(self: &Self, f: F) -> Array<T> {
        let matched = Array<T>();
        for &elem in self {
            if f(elem) {
                matched.append(elem);
            }
        }
        return matched;
    }


    /// Returns true if the array contains the element
    //#[enable_if(T: Equatable)]
    fn contains<E>(self: &Self, element: E) -> bool {
        // TODO drop the additional template parameter
        for &elem in self {
            if elem == element {
                return true;
            }
        }
        return false;
    }


    /// Returns true if the array contains an element which matches the predicate
    fn contains<F>(self: &Self, f: F) -> bool {
        for &elem in self {
            if f(elem) {
                return true;
            }
        }
        return false;
    }

    }


    fn dealloc(self: &Self) {
        if __is_destructible<T>() {
            for &elem in self {
                elem.__dealloc();
            }
        }
        dealloc(self.data);
    }
}

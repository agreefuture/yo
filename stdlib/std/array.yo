use ":std/memory";

struct ArrayIterator<T> {
    array: &Array<T>,
    idx: i64
}

impl ArrayIterator {
    fn hasNext(self: &Self) -> bool {
        return self.idx < self.array.size;
    }

    fn next(self: &Self) -> &T {
        let &elem = self.array[self.idx];
        self.idx += 1;
        return elem;
    }
}



struct Array<T> {
    data: *T,
    size: i64,
    allocSize: i64
}

impl Array {
    fn init(self: &Self) {
        self.data = alloc<T>(10);
        self.allocSize = 10;
    }

    fn init(self: &Self, other: &Array<T>) {
        self.allocSize = other.allocSize;
        self.data = alloc<T>(cast<size_t>(self.allocSize));
        while self.size < other.size {
            self._constructInPlace(self.size, other[self.size]);
            self.size += 1;
        }
    }

    // Inserts a new element, invoking the copy constructor if necessary
    fn _constructInPlace(self: &Self, index: i64, element: &T) {
        if __is_constructible<T>() {
            self.data[index].init(element);
        } else {
            self.data[index] = element;
        }
    }


    fn append(self: &Self, element: T) {
        if self.size == self.allocSize {
            fatalError("TODO: Resize");
        }
        self._constructInPlace(self.size, element);
        self.size += 1;
    }

    fn operator [] (self: &Self, index: i64) -> &T {
        return self.data[index];
    }

    fn iterator(self: &Self) -> ArrayIterator<T> {
        return ArrayIterator<T>(self, 0);
    }

    fn dealloc(self: &Self) {
        if __is_destructible<T>() {
            let idx = 0;
            while idx < self.size {
                self.data[idx].__dealloc();
                idx += 1;
            }
        }
        dealloc(self.data);
    }
}

use "std/string";
use "std/runtime";

type Array(count: int, _allocatedLength: int, _backing: int);

// TODO write tests for all of this!


impl Array {
    // Create a new Array
    static fn new(): Array {
        ret Array::init(0, 5, runtime::alloc(5));
    }

    static fn _fromConstantLiteral(address: int): Array {
        // since the array we get in `address` also contains its length (at index 0),
        // we allocate a new array as our backing and free the one we got.
        // This is important for Array.dealloc to work properly.
        // (If we just set `_backing` to `address + 1`, we couldn't free it because there's no
        // way of knowing whether the array was created via literal or not)
        val length: int = address[0];
        val backing: int = runtime::alloc(length);

        for i in 0..<length {
            backing[i] = address[i + 1];
        }

        runtime::free(address);
        ret Array::init(length, length, backing);
    }


    // Add an object to the array
    // TODO make `object` id and require it to be a heap allocated instance
    fn add(self: Array, object: int): int {
        if self.count == self._allocatedLength {
            // array is full, we need to switch to a bigger backing

            // TODO come up w/ some clever algorithm determining the new backing length?
            self._resizeBacking(self._allocatedLength + 10);
        }

        self._backing[self.count] = object;
        self.count = self.count + 1; // TODO make this `self.count += 1;`
        ret self.count;
    }


    // Get the object at `index`
    fn get(self: Array, index: int): int {
        ret self._backing[self._normalizeIndexAndCheckBounds(index)];
    }


    // Set the object at `index`
    // Returns the previous value
    fn set(self: Array, index: int, object: int): int {
        index = self._normalizeIndexAndCheckBounds(index);
        val oldValue: int = self.get(index);
        self._backing[index] = object;
        ret oldValue;
    }


    // Check whether the array contains an object
    fn contains(self: Array, object: int): int {
        if self.indexOf(object) == -1 {
            ret 0;
        }
        ret 1;
    }


    // Get the first index of an object in the array
    // Returns -1 if the array does not contain the object
    fn indexOf(self: Array, obj: int): int {
        for i in 0..<self.count {
            if self.get(i) == obj {
                ret i;
            }
        }
        ret -1;
    }


    // Remove all occurrences of an object from the array
    fn removeObject(self: Array, object: int): void {
        for i in 0..<self.count {
            if self.get(i) == object {
                self.removeObjectAtIndex(i);
            }
        }
    }


    // Remove the object at the specified index
    fn removeObjectAtIndex(self: Array, index: int): void {
        index = self._normalizeIndexAndCheckBounds(index);

        self.count = self.count - 1;

        Array::_copy(self._backing, index + 1, self._backing, index, self.count - index);

        if (self._allocatedLength - self.count) >= 5 {
            self._resizeBacking(self._allocatedLength - 5);
        }
    }


    fn sort(self: Array): void {
        runtime::sort(self._backing, self.count);
    }

    fn sortf(self: Array, f: fn<int, (int, int)>): void {
        runtime::sortf(self._backing, self.count, f);
    }


    // Get the number of objects in the array
    fn length(self: Array): int {
        ret self.count;
    }


    fn dealloc(self: Array): int {
        runtime::free(self._backing);
    }


    // Helpers
    fn _normalizeIndexAndCheckBounds(self: Array, index: int): int {
        if index < 0 {
            index = self.count + index;
        }

        if index > self.count - 1 {
            runtime::fatalError("array index out of bounds");
        }

        ret index;
    }

    // Move to a smaller/larger backing
    // Also updates `_allocatedLength`
    fn _resizeBacking(self: Array, newSize: int): void {
        val newBacking: int = runtime::alloc(newSize);

        Array::_copy(self._backing, 0, newBacking, 0, self.count);

        runtime::free(self._backing);
        self._backing = newBacking;
        self._allocatedLength = newSize;
    }


    // Basically java's `Syatem.arraycopy`
    static fn _copy(source: int, sourceIndex: int, destination: int, destinationIndex: int, length: int): void {
        for i in 0..<length {
            destination[destinationIndex + i] = source[sourceIndex + i];
        }
    }
}

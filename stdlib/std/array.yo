use "std/string";

type Array(count: int, _allocatedLength: int, _backing: int);

// TODO write tests for all of this!


impl Array {
    // Create a new Array
    static fn new(): Array {
        ret Array::init(0, 5, runtime::alloc(5));
    }

    static fn _fromConstantLiteral(address: int): Array {
        // since the array we get in `address` also contains its length (at index 0),
        // we allocate a new array as our backing and free the one we got.
        // This is important for Array.dealloc to work properly.
        // (If we just set `_backing` to `address + 1`, we couldn't free it because there's no
        // way of knowing whether the array was created via literal or not)
        val length: int = address[0];
        val backing: int = runtime::alloc(length);

        val idx: int = 0;
        while idx < length {
            backing[idx] = address[idx + 1];
            idx += 1;
        }

        runtime::free(address);
        ret Array::init(length, length, backing);
    }


    // Add an object to the array
    // TODO make `object` id and require it to be a heap allocated instance
    fn add(self: Array, object: int): int {
        if self.count == self._allocatedLength {
            // array is full, we need to switch to a bigger backing

            // TODO come up w/ some clever algorithm determining the new backing length?
            val newLength: int = self._allocatedLength + 10;
            val newBacking: int = runtime::alloc(newLength);

            val idx: int = 0;
            while idx < self.count {
                newBacking[idx] = self._backing[idx];
                idx += 1;
            }

            runtime::free(self._backing);
            self._backing = newBacking;
            self._allocatedLength = newLength;
        }

        self._backing[self.count] = object;
        self.count = self.count + 1; // TODO make this `self.count += 1;`
        ret self.count;
    }


    // Get the object at `index`
    fn get(self: Array, index: int): int {
        ret self._backing[self._normalizeIndexAndCheckBounds(index)];
    }


    // Set the object at `index`
    // Returns the previous value
    fn set(self: Array, index: int, object: int): int {
        index = self._normalizeIndexAndCheckBounds(index);
        val oldValue: int = self.get(index);
        self._backing[index] = object;
        ret oldValue;
    }


    // Check whether the array contains an object
    fn contains(self: Array, object: int): int {
        val idx: int = 0;
        while idx < self.count - 1 {
            if self.get(idx) == object {
                ret 1;
            }
            idx += 1;
        }

        ret 0;
    }


    // Remove an object from the array
    fn remove(self: Array, index: int): int {
        // TODO
    }


    // Get the number of objects in the array
    fn length(self: Array): int {
        ret self.count;
    }


    fn dealloc(self: Array): int {
        runtime::free(self._backing);
    }


    // Helpers
    fn _normalizeIndexAndCheckBounds(self: Array, index: int): int {
        if index < 0 {
            index = self.count + index;
        }

        if index > self.count - 1 {
            runtime::fatalError("array index out of bounds");
        }

        ret index;
    }
}

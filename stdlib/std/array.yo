use "std/string";
use "std/string_builder";

type Array (
    _count: int,
    _allocatedLength: int,
    _backing: int
);

// TODO write tests for all of this!


impl Array {
    // Create a new Array
    static fn new(): Array {
        ret Array::init(0, 10, runtime::alloc(10));
    }

    // Create a new Array from the contents of the heap, at the specified address
    // Invoked by the compiler when using array literals consisting exclusively of integer literals
    static fn _fromConstantLiteral(address: int): Array {
        // since the array we get in `address` also contains its length (at index 0),
        // we allocate a new array as our backing and free the one we got.
        // This is important for Array.dealloc to work properly.
        // (If we just set `_backing` to `address + 1`, we couldn't free it because there's no
        // way of knowing whether the array was created via literal or not)
        val length: int = address[0];
        val backing: int = runtime::alloc(length);

        // TODO runtime::copy_array
        for i in 0..<length {
            backing[i] = address[i + 1];
        }

        runtime::free(address);
        ret Array::init(length, length, backing);
    }


    // Add an object to the array
    // TODO make `object` id and require it to be a heap allocated instance
    fn append(self: Array, object: id): int {
        if self._count == self._allocatedLength {
            // array is full, we need to switch to a bigger backing

            // TODO come up w/ some clever algorithm determining the new backing length?

            // TODO what if `self` is an array from a literal? that means that _allocatedLength == count for any count.
            // the issue w/ that is that if we just add 10, we might have an odd allocated length
            self._resizeBacking(self._allocatedLength + 10);
        }

        self._backing[self._count] = object;
        runtime::retain(object);
        // TODO make this `self._count += 1;`
        self._count = self._count + 1;
        ret self._count;
    }


    // Get the object at `index`
    fn get(self: Array, index: int): id {
        ret self._backing[self._normalizeIndexAndCheckBounds(index)] as id;
    }


    // Set the object at `index`
    // Returns the previous value
    fn set(self: Array, index: int, object: id): id {
        index = self._normalizeIndexAndCheckBounds(index);
        val oldValue = self.get(index);
        runtime::release(oldValue);
        self._backing[index] = object;
        runtime::retain(object);
        ret oldValue;
    }


    // Check whether the array contains an object
    fn contains(self: Array, object: any): bool {
        if self.indexOf(object) == -1 {
            ret false;
        }
        ret true;
    }


    // Get the first index of an object in the array
    // Returns -1 if the array does not contain the object
    fn indexOf(self: Array, obj: any): int {
        for i in 0..<self._count {
            if self.get(i) == obj {
                ret i;
            }
        }
        ret -1;
    }


    // Remove all occurrences of an object from the array
    fn remove(self: Array, object: id): void {
        NotYetImplemented();
        // TODO take a reduced length due to mutations into account!!!
        for i in 0..<self._count {
            // TODO we probably should also check the object's hash values or call isEqual or something like that
            if self.get(i) == object {
                self.removeAtIndex(i);
            }
        }
    }


    // Remove the object at the specified index
    fn removeAtIndex(self: Array, index: int): void {
        index = self._normalizeIndexAndCheckBounds(index);

        runtime::release(self.get(index));

        self._count = self._count - 1;

        runtime::copy_array(self._backing, index + 1, self._backing, index, self._count - index);

        if (self._allocatedLength - self._count) >= 5 {
            self._resizeBacking(self._allocatedLength - 5);
        }
    }


    // Sort the array in ascending order
    fn sort(self: Array): void {
        runtime::sort(self._backing, self._count);
    }


    // Sort the array using a custom sorting function
    fn sortf(self: Array, f: fn<(any, any): int>): void {
        runtime::sortf(self._backing, self._count, f);
    }


    fn forEach(self: Array, f: fn<(id): void>): void {
        for i in 0..<self._count {
            f(self.get(i));
        }
    }


    fn enumerate(self: Array, f: fn<(int, id): void>): void {
        for i in 0..<self._count {
            f(i, self.get(i));
        }
    }


    fn map(self: Array, f: fn<(id): id>): Array {
        val newArray = Array::new();

        for i in 0..<self._count {
            newArray.append(f(self.get(i)));
        }

        ret newArray;
    }


    fn filter(self: Array, f: fn<(id): bool>): Array {
        val newArray: Array = Array::new();

        for i in 0..<self._count {
            val element = self.get(i);
            if f(element) {
                newArray.append(element);
            }
        }
        ret newArray;
    }


    fn reduce(self: Array, initial: any, f: fn<(any, any): any>): any {
        for i in 0..<self._count {
            initial = f(initial, self.get(i));
        }

        ret initial;
    }


    fn reduceInto(self: Array, obj: any, f: fn<(any, any): void>): any {
        self.forEach(|x| -> {
            f(obj, x);
        });

        ret obj;
    }


    // Get the number of objects in the array
    fn count(self: Array): int {
        ret self._count;
    }


    fn dealloc(self: Array): void {
        for i in 0..<self._count {
            runtime::release(self.get(i));
        }
        runtime::free(self._backing);
    }


    fn description(self: Array): String {
        val desc = StringBuilder::new();
        desc.append("Array {\n");

        // TODO append commas to all elements except the last
        self.forEach(|x| -> {
            desc.append_format("    %s\n", [Object::description(x)]);
        });

        desc.append("}");
        ret desc.stringValue();
    }


    //
    // MARK: Helpers
    //

    fn _normalizeIndexAndCheckBounds(self: Array, index: int): int {
        if index < 0 {
            index = self._count + index;
        }

        if index > self._count - 1 {
            runtime::fatalError("array index out of bounds");
        }

        ret index;
    }

// TODO
//    fn hashValue(self: Array): int {
//        ret 12;
//    }


    // Move to a smaller/larger backing
    // Also updates `_allocatedLength`
    fn _resizeBacking(self: Array, newSize: int): void {
        val newBacking: int = runtime::alloc(newSize);

        runtime::copy_array(self._backing, 0, newBacking, 0, self._count);

        runtime::free(self._backing);
        self._backing = newBacking;
        self._allocatedLength = newSize;
    }
}

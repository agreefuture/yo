use ":std/memory";

struct ArrayIterator<Element> {
    array: &Array<T>,
    idx: i64
}

impl ArrayIterator {
    fn init(self: &Self, array: &Array<Element>) {
        self.init(array, 0);
    }

    fn hasNext(self: &Self) -> bool {
        return self.idx < self.array.size;
    }

    fn next(self: &Self) -> &Element {
        let &elem = self.array[self.idx];
        self.idx += 1;
        return elem;
    }
}



struct Array<Element> {
    data: *Element,
    size: i64,
    allocSize: i64
}

impl Array {
    fn init(self: &Self) {
        self.data = alloc<Element>(10);
        self.allocSize = 10;
    }

    fn init(self: &Self, other: &Array<Element>) {
        self.allocSize = other.allocSize;
        self.data = alloc<Element>(cast<size_t>(self.allocSize));
        while self.size < other.size {
            self._constructInPlace(self.size, other[self.size]);
            self.size += 1;
        }
    }

    fn operator [] (self: &Self, index: i64) -> &Element {
        return self.data[index];
    }

    fn iterator(self: &Self) -> ArrayIterator<Element> {
        return ArrayIterator<Element>(self);
    }


    fn append(self: &Self, element: Element) {
        if self.size >= self.allocSize - 2 {
            self._resize(25); // TODO dynamically calculate growth factor!
        }
        self._constructInPlace(self.size, element);
        self.size += 1;
    }

    
    fn remove(self: &Self, index: i64) {
        fatalError("TODO: implement");
    }


    // Inserts a new element, invoking the copy constructor if necessary
    fn _constructInPlace(self: &Self, index: i64, element: &Element) {
        if __is_constructible<Element>() {
            self.data[index].init(element);
        } else {
            self.data[index] = element;
        }
    }

    
    fn _resize(self: &Self, diff: i64) {
        let ptr = alloc<Element>(cast<size_t>(self.allocSize + diff));
        memcpy(bitcast<*i8>(ptr), bitcast<*i8>(self.data), cast<size_t>(self.size) * sizeof<Element>());
        dealloc(self.data);
        self.data = ptr;
    }




    fn filtered<F>(self: &Self, f: F) -> Array<Element> {
        let matched = Array<Element>();
        for &elem in self {
            if f(elem) {
                matched.append(elem);
            }
        }
        return matched;
    }


    /// Returns true if the array contains the element
    fn contains(self: &Self, element: Element) -> bool {
        for &elem in self {
            if elem == element {
                return true;
            }
        }
        return false;
    }


    /// Returns true if the array contains an element which matches the predicate
    fn contains<F>(self: &Self, f: F) -> bool {
        for &elem in self {
            if f(elem) {
                return true;
            }
        }
        return false;
    }



    fn dealloc(self: &Self) {
        if __is_destructible<Element>() {
            for &elem in self {
                elem.__dealloc();
            }
        }
        dealloc(self.data);
    }
}
